История применения и оценки функционального программирования.
=======

- [История применения и оценки функционального программирования.](#история-применения-и-оценки-функционального-программирования)
- [Часть 2: Великое уравнивание](#часть-2-великое-уравнивание)
  - [Синтаксическая элегантность уравнений](#синтаксическая-элегантность-уравнений)
    - [Бегство из MACSYMA](#бегство-из-macsyma)
    - [В Ньюкасл со своими уравнениями](#в-ньюкасл-со-своими-уравнениями)
    - [Небыстрая сортировка](#небыстрая-сортировка)
    - [Случай на мосту через поток данных](#случай-на-мосту-через-поток-данных)
- [Литература](#литература)


Часть 2: Великое уравнивание
============================

> Существует ряд довольно похожих языков, из которых, пожалуй, наиболее известен HOPE. И то, что представлено здесь, можно считать иллюстрацией современного стиля функционального программирования и противопоставить его более традиционному стилю функционального программирования, основанному на LISP.   
> Дэвид Тернер, Функциональные программы как исполняемые спецификации [Turn84].    

В нулевой части истории мы выяснили, что к началу 80-х годов первый функциональный язык современного вида, с выводом полиморфных типов, АлгТД и паттерн-матчингом уже существовал [Burs80]. Но вышло так, что ни один из первого поколения компиляторов ФЯ, обзор которых мы сделали в первой части, не начал с имплементации такого языка.   
В результате в начале 80-х появилось заметное число самобытных функциональных языков. Но им не долго оставалось быть существенно отличающимися друг от друга, да и вообще быть.   
Вскоре начался процесс их унификации. Он включал в себя и скоординированные усилия по созданию одного универсального языка, и стремления отдельных разработчиков добавить в свой язык фичи как у всех. В результате немногие оставшиеся функциональные языки Эдинбургской исследовательской программы приобрели свой современный, узнаваемый вид. Об этом процессе мы и расскажем во второй части нашей истории.   

## Синтаксическая элегантность уравнений

Не смотря на все описанные в прошлой части успехи по компиляции ФЯ, HOPE - первый ФЯ современного вида - все еще оставался имплементированным с помощью медленного интерпретатора. Чего недоставало компилируемым функциональным языкам для того, чтоб догнать передний край худо-бедно интерпретируемых?   
Все они уже функциональные, идеи Берджа восторжествовали после пары не самых простых для них десятилетий. Даже некоторые лисперы уже узнали про возвращение функций из функций и о том, что это неплохо бы поддержать в имплементации языка. Конечно, то, что несколько имплементаторов ФЯ теперь понимают возвращение функций из функций - это еще не значит, что это что-то широко известное. И донесение этого до более широкой общественности - основная тема и предназначение статей и докладов из которых можно было впервые узнать об остальных фичах.   
Вывод типов Хиндли-Милнера достаточно хорошо известен и обычно либо уже имплементирован (в VAX-ML, LML и Cambridge ML) или не имплементирован потому, что автору языка хотелось бы чего-то большего и это что-то большее уже имплементировано вместо него (Ponder, Poly).   
Хуже всего дела с АлгТД и уравнениями с паттерн-матчингом. Глава Хоара про композитные типы данных [Hoar72], написанная до изобретения BNF-образной формы АлгТД намного известнее, чем статья в которой такая форма описана [Hoar75]. Паттерн матчинг в VAX-ML самобытный, работающий не с привычными АлгТД. В ALFL есть уравнения с ПМ как в SASL, работающие только со встроенными списками.   
Работавшие над языками с уравнениями с ПМ Бурсталл, Дарлингтон и Тернер не достаточно писали о своей работе над уравнениями с ПМ. В 70-е все эти уравнения оставались в обычно диссертациях, университетских отчетах и руководствах пользователя. Тот кто читал про работу Дарлингтона с Бурсталлом, как правило читал о ней в статье [Darl76] в которой уравнений еще нет. И если это легко объяснить тем, что когда статья была написана - уравнений с ПМ еще не было и статья просто долго ждала публикации, то похожую проблему со статьей Тернера [Turn79] объяснить сложнее. В самой популярной и цитируемой статье Тернера об SKI-интерпретаторе, вдохновившей так много героев нашей истории, Тернер по какой-то причине не посчитал нужным продемонстрировать уравнения с ПМ в новом SASL 76. Код похож на написанный на старом SASL и, следовательно, на ISWIM.   
Карделли, скорее всего узнавший об уравнениях с ПМ таким же образом как и Тернер, приехав в Эдинбург, выбрал имплементировать ПМ и композитные типы данных не так как в HOPE. И Дарлингтон с Тернером выбрали (пока что) не имплементировать компиляторы своих языков с уравнениями для обычных машин.   
В результате, книга [Hend80] об ФП одного из изобретателей ленивости Хендерсона, вышедшая спустя пять лет после книги Берджа все так же использует ISWIM, а не язык уравнений с паттерн-матчингом. Хендерсон описывает разбор структур в неформальной нотации, напоминающей Ландинскую, после чего имплементирует со всеми предикатами `if`-ми и селекторами. Одноуровневый ПМ и `case`-выражение упоминаются только как интересная концепция с одним примером. При том, что Хендерсон ссылается на работы Бурсталла и Тернера. Но, конечно же те, в которых они не посчитали нужным продемонстрировать уравнения с ПМ.   

### Бегство из MACSYMA

По большему счету все эти уравнения с ПМ в функциональных языках были представлены миру только на первых ФП конференциях в 80-е, когда работа над первыми компиляторами ФЯ уже шла вовсю.   
В том, что первые ФП-конференции состоялись только в 80-е нет ничего удивительного. Как мы уже выяснили в нулевой части, до начала 80-х функционального программирования не было. Но чего наши читатели, скорее всего, не ожидают, так это того, что первая ФП-конференция была и первой регулярной Лисп-конференцией [Stee82b]. До нее была только конференция 64-го года в Мехико.   
Где же лисперы докладывали о своей бурной деятельности, например о разработке MacLisp [Whit77] или NIL [Whit79]? Разумеется, на конференциях пользователей MACSYMA. Ведь, как мы уже выяснили в нулевой части, Лисп - это в первую очередь язык для имплементации MACSYMA, а все остальное - как повезет.   
Но в 80-е Лисп довольно успешно освобождается от главного бремени (и смысла) своего существования, так что есть все основания начать проводить конференцию посвященную именно Лиспу.   
Конференцию организовали и профинансировали Джон Аллен (John Allen) со своей женой Рут Дэвис (Ruth E. Davis) [McJo22]. Аллен работал в Стенфорде над тем самым мини-Маклиспом для не таких богатых лисперов из Стенфордского мини-Мака, который позднее использовал уже в Эдинбургском мини-Маке Милнер для написания LCF/ML. В конце 70-х Аллен основал The Lisp Company, которая разрабатывала Лисп для x86-машин.   
Джон Аллен - не обычный лиспер, но лиспер, написавший книгу о Лиспе [Alle78], в которой ссылается не только на большинство имеющих какое-то отношение к ФП лисперов, но и на большинство героев обоекембриджской и ранней эдинбургской частей нашей истории, а также оказавших на них влияние. На Бойера, Берджа, Бурсталла, Черча, Карри, Дарлингтона, Гордона, Ландина, Милнера, Джея Мура, Джеймса Морриса, Локвуда Морриса, Ньюи, Плоткина, Поплстоуна, Рейнольдса, Скотта, Стрейчи (в том числе на тот самый доклад [Stra67]), Вадсворта (в том числе и на его диссертацию про редукцию графов), Вюийемена и, чтоб охватить совсем уж все имеющее отношение к ФП, Вейнгаардена, Algol 68 и прочих алголистов.   
Что только частично можно объяснить стенфордскими связями авторов LCF и вообще отличием стенфордских лисперов от гораздо более стойко сопротивляющихся всему эдинбургскому лисперов МТИ.   
Так что нет ничего удивительного в том, что он не хотел ограничиваться только Лиспом [Alle2005] и организовал первую конференцию по Лиспу, ставшую первой в серии проходящих раз в два года конференций по Лиспу и функциональному программированию (Lisp and Functional Programming Conference).   
Конференция прошла в конце августа 1980-го года в Стенфорде, вскоре после первой конференции AAAI. Да первые ИИ-конференции, AAAI и ICML тоже начали организовывать только в 1980-ом году. Для тех, кто работает над каким-нибудь ИИ, который не является системой компьютерной алгебры MACSYMA.   
Именно на этой конференции можно было услышать доклад о HOPE [Burs80] (и SKIM, что не так важно для этой части нашей истории).   
Доклад о HOPE содержит редкий пример объявления АлгТД современного вида  

```
data otree == empty ++ tip(num)
                    ++ node(otree#num#otree)
```

и разбирающих его функций, написанных как уравнения с ПМ

```
dec insert : num#otree -> otree

--- insert(n,empty) <= tip(n)
--- insert(n,tip(m)) 
             <= n<m then node(tip(n),m,empty)
                    else node(empty,m,tip(n))
--- insert(n,node(t1,m,t2)) 
             <= n<m then node(insert(n,t1),m,t2)
                    else node(t1,m,insert(n,t2))
```

Примеров работы со встроенными типами вроде списков и натуральных чисел в то время было куда больше, тем более, что SASL и KRC поддерживали только их и большая часть ранних демонстраций уравнений с ПМ - это SASL и KRC.   
Существует отчет [Stee82b] Стила о конференции с комментариями о каждом докладе. Так что у нас есть возможность узнать, что лисперы думали о ФЯ современного вида, когда они только появились.   
Авторы утверждают, пишет Стил, что не пытаются быть оригинальными, а просто выбирают уже проверенные, хорошо изученные идеи. Но само сочетания идей - оригинально, решает Стил.   
Итак, Стил признает HOPE и, соответственно, ФЯ современного вида чем-то новым. Но и для нового можно найти место в уже существующей классификации среди знакомых вещей.   
Так, в нулевой части мы выяснили, что авторы языков алгебраической спецификации считали HOPE языком алгебраической спецификации. Пишущий главу о логических языках О'Доннел решал, что HOPE - логический язык. И Бурсталл не то чтобы был с ним не согласен. Тернер считал, что если и не логический, то ближайший родственник логических языков [Turn84].   
Так что ничего удивительного в том, что лиспер решил, что HOPE - это типизированный, аппликативный Лисп. Лисперы даже включили интерпретатор HOPE, написанный в Эдинбурге на POP-2 в список имплементаций Лиспа, который составляли на конференции [Stee82b].   

### В Ньюкасл со своими уравнениями

В июле 81-го в Университете Ньюкасла состоялось мероприятие, сравнимое с тем, чем была летняя школа 63-го года по "нечисленным вычислениям" для героев нулевой части нашей истории.   
Десять лекторов, в том числе и такие важные герои истории ФП как Сассман, Уайз, Хендерсон и Джеймс Моррис прочли десять коротких курсов из трех-четырех лекций восьмидесяти слушателям, среди которых были Джон Хьюз и Саймон Пейтон-Джонс [Huda07]. Но важнейшими для продвижения языков с уравнениями и паттерн-матчингом были доклады Тернера и Дарлингтона.   
Еще три доклада должны были прочесть приглашенные знаменитости, но Дана Скотт и ФП-алголист Фриц Бауэр не приехали, прислав замены. Не для всех эти обстоятельства оказались неудачными, заменявший Бауэра докладчик не дал упасть с лестницы третьей и единственной приехавшей приглашенной знаменитости - Эдсгеру Дейкстре.   
Дейкстра прослушал половину лекций и написал отчет [Dijk81] о них. Достаточно критический даже по меркам Дейкстры отчет, в котором для лисперов не нашлось добрых слов. Но отзыв Дейкстры о докладах Дарлингтона и Тернера более-менее положительный, хотя и не без критики и иронии над грандиозной недописанной еще системы трансформации программ Дарлингтона. Дейкстра утверждает, что в докладе Тернера было больше нового, чем во всех прочих, но и преувеличивает важность своей темы Тернер больше, чем все остальные докладчики.   
Дейкстра не упоминает в своем отчете то, что он уже знаком с Тернером и его работами. Но Тернер вспоминает [Hoar22], что они с Дейкстрой познакомились за год до того, что Тернер обсуждал с Дейкстрой SASL. Так что новое в данном случае, скорее всего, не для Дейкстры.   
Сборник Ньюкаслских лекций вышел в 82-ом году под названием "Функциональное программирование и его применения" [Darl82].   
Функциональное программирование привлекло к себе внимание, констатируют составители сборника Дарлингтон, Хендерсон и Тернер. Почему? Из-за лекции Бэкуса, продолжающегося "кризиса программного обеспечения" и "революции аппаратного обеспечения". "Кризисом программного обеспечения" называют то, что развитие обычных языков программирования и методологии программирования не дает ожидаемого роста надежности и падения стоимости разработки программного обеспечения. Ничего удивительного, отмечает Тернер. Обычные языки слишком похожи друг на друга, изменения были не достаточно радикальными, чтоб от них был заметный эффект. Разумеется, у Тернера есть идеи достаточно радикальных изменений.   
"Революцией аппаратного обеспечения" Дарлингтон, Хендерсон и Тернер называют то, что равномощный мэйнфрейму 70-х компьютер становится все меньше и дешевле. Как мы уже выяснили, удешевление памяти сыграло решающую роль в том, что функциональное программирования стало возможным на практике. Но составители сборника имеют в виду не это, а неминуемое появление параллельных компьютеров, для программирования которых лучше использовать ФЯ. Как мы уже выяснили в предыдущей части, в последующие пять лет это не нашло особого подтверждения.   
Сборник лекций и открывающая его лекция Тернера [Turn82] "Рекурсивные уравнения как язык программирования" полны рассуждений о том, как нужно ФП для параллельных компьютеров и как параллельные компьютеры нужны для ФП. Мы уже кратко останавливались на этих идеях.   
Но, к счастью, функциональное программирование нужно не только для программирования параллельных компьютеров. Свойства функционального кода легче доказывать. Функциональный код легче трансформировать в более эффективный. Но главное, функциональное программирование нужно для того, чтоб писать меньше кода.   
Исследования показали, объясняет Тернер, не давая ссылок на эти исследования, что программист производит за год фиксированное количество отлаженного и документированного кода. Примерно полторы тысячи строк. Независимо от того, на чем он эти строки пишет, на ассемблере, на Фортране или на ФЯ. Но, разумеется, полторы тысячи строк на Фортране это не то же самое, что те же полторы тысячи на ассемблере. Код на Фортране в пять - десять раз короче кода на ассемблере, который делает то же, объясняет Тернер, не давая ссылок и в этом случае и не объясняя какого именно ассемблера. Поэтому Фортран такой грандиозный шаг вперед в развитии программирования. Он делает программиста в 5-10 раз продуктивнее.   
Но со времен появления Фортрана прошло уже 25 лет, а новый язык, который был бы для Фортрана тем же, чем Фортран был для ассемблера, все не появлялся. Кризис программного обеспечения!    
Но не нужно впадать в отчаянье. Такие языки долго не появлялись, но, наконец, появились. Это аппликативные, они же функциональные языки. Но, конечно же, не Лисп, который "все еще приходит на ум, когда говорят о функциональных языках", поясняет Тернер. Функциональные языки, которые он имеет в виду - это SASL и KRC.   
Смотрите сами. Вот Лисп, показывает Тернер: 

```lisp
DEFINE(((A (LAMBDA (M N)
      (COND ((ZEROP M) (PLUS N 1))
            ((ZEROP N) (A (SUB1 M) 1))
            (T (A (SUB1 M) (A M (SUB1 N)))
            ))))))
```

А вот KRC:

```
A 0 n = n + 1
A m 0 = A (m-1) 1
A m n = A (m-1) (A m (n-1))
```

В своей лекции из того же сборника [Darl82] Дарлингтон сравнивает уравнения с паттерн-матчингом и многоветочные `if` наподобие лисповых в одном и том же языке:

```haskell
fact(0)=1
fact(n+1)=(n+1)*fact(n)
```

```haskell
fact(n)=1 if n=0
        n*fact(n-1) otherwise
```

И этот язык скорее NPL, чем HOPE. Дарлингтон упоминает HOPE, но в примерах не использует синтаксические детали, которые появились в NPL/HOPE с тех пор как Дарлингтон ушел из Эдинбургского Университета.   
Эти примеры в какой-то степени демонстрируют преимущества уравнений с паттерн-матчингом. Но не так хорошо, как сравнение из доклада Уоррена о ненужности Лиспа [Warr77] [Warr77b]. Паттерн матчинг в примере Уоррена несколько интереснее потому, что разбирает списки. И Уоррен сравнивает паттерн матчинг Пролога с селекторным подходом Лиспа, используя его несуществующий M-синтаксис из статей, вместо существующего скобочного. Но Тернер и не скрывает, что хочет показать Лисп в плохом свете, а не только селекторный подход. Дарлингтон же не особенно заинтересован в сравнении с чем бы то ни было, он приводит конкатенацию списков в виде уравнений с ПМ в примере на следующей после факториала странице, но ни с чем не сравнивает.   

```
append(nil,l2)=l2
append(cons(n,l1),l2)=cons(n,append(l1,l2)).
```

Но нужно ли? Программисты уже хорошо выучили селекторный подход и, вероятно, не нуждаются в напоминании для сравнения.   
Доклад Тернера продолжается демонстрацией других примеров, в числе прочих и не-решета не-Эратосфена,

```haskell
primes = sieve [2..]
sieve (p:x) = p:sieve {n;n<-x;n%p>0}
```

с помощью которого демонстрируют и преимущества Хаскеля на его официальном сайте и сорок лет спустя, в момент написания этих слов.    
Завершается лекция Тернера полным текстом стандартной библиотеки KRC в которой демонстраций уравнений с ПМ более чем достаточно. Демонстраций многих современных возможностей, но не обязательно современного вида:  

```haskell
filter f [] = []
filter f (a:x) = a:filter f x, f a
               = filter f x
```

Тернер заявляет, что его опыт аппликативного программирования раз за разом подтверждает, что код на SASL-образных языках на порядок короче, чем эквивалентный код на традиционных языках программирования.   
Тернер не приводит никаких сравнений и примеров таких успехов и даже не говорит какой именно порядок имеется в виду. Даже выбранный им пример кода плохого Лиспа не в десять раз длиннее, чем пример кода хорошего KRC.   

### Небыстрая сортировка

Но, конечно, среди функциональных программистов позднее нашлись желающие подтвердить, что код на ФЯ в 2-10 раз короче. В зависимости от смелости трактовки слова "порядок". Подробность описаний этих подтверждений серьезно варьируется.   
Так Вадлер в стенограмме обсуждения одного из более поздних докладов Тернера [Turn84] вспоминает, что написал одну и ту же программу на Лиспе и KRC. Кода на Лиспе получилось 40 страниц, т.е., надо полагать, 1.5-3 тыс. строк. Кода на KRC, вышло 4 страницы.   
Наш старый знакомый по рассказу о SKI-машине NORMA Ричардс пишет [Rich85], что лексический анализатор (видимо, часть имплементации ARC SASL?) получается размером в 800 строк на Паскале-образном системном языке мэйнфрейма B1900, 400 строк на Лиспе и только 40 строк на ARC SASL.   
Подробнее всего описан один из самых скромных успехов. В 83-ем году Саймон Пейтон-Джонс написал [SPJ85] на SASL генератор парсеров. Получилось 835 строк. Но Пейтон-Джонсу не удалось написать в десять раз больше строк кода на BCPL. Получилась только 1501 строка. Нужно заметить, справедливости ради, что BCPL не особенно многословный язык из-за отсутствия сигнатур типов и довольно легковесного ФЯ-образного синтаксиса. В статье достаточно примеров кода Пейтон-Джонса на SASL (но не полный текст программы), но не на BCPL. Как он писал на BCPL можно посмотреть в статье про сравнение SKI-интерпретатора с SECD [SPJ82].   
Но даже такие совсем небольшие примеры - слишком большие для демонстрации в статье о преимуществах ФП. И пример подходящего размера был найден. Во времена первых ФП-конференций он еще не был готов, но вскоре после них начал использоваться для демонстрации краткости функциональных языков. Да, это был так называемый "квиксорт".   
Мы уже встречались с его ранними версиями в нулевой части нашей истории. Первоначально, "квиксорт" Берджа-Левенворта не был таким уж немногословным и был вполне сравним с квиксортом на Паскале по числу строк кода. У Ван Эмдена и Тернера он стал несколько компактнее благодаря паттерн-матчингу, но все еще не демонстрацией краткости, а в первую очередь демонстрацией того, что на логическом или функциональном языке вообще можно написать не совсем тривиальную программу.   
Свою финальную форму этот "квиксорт" принял только с появлением ЦФ-нотации в языках Тернера. И придал ему эту финальную форму работавший Университете Кента над диссертацией Силвио Мейра (Sílvio Romero de Lemos Meira).   
Рассказывая о "квиксорте" Мейры, Тернер ссылается [Turn84] на неотсканированный отчет [Meir83] 83-го года об имплементации сортировки на KRC. Отчет до нас не дошел, но дошло сообщение [Meir83b] Мейры в usenet группе net.applic, от 16 августа 83 в котором есть такой KRC код:   

```
quick [] = [] ;
quick (a:x) = quick {y | y <- x; y <= a} ++
            a:quick {z | z <- x; z > a} ;
```

В стандартной библиотеке [Turn83] новой версии SASL c ЦФ-нотацией от ноября 83-го года "квиксорт" занимает всего-то две строки:   

```
sort () = ()
sort (a:x) = sort {b <- x; b<=a} ++ a : sort {b <- x; b>a}
```

Квиксорт на Паскале - пара десятков строк. Сокращение кода на десятичный порядок продемонстрировано.   
Ричардс [Rich85] сравнивает 18 строк квиксорта на Паскале с "квиксортом" на ARC SASL, который он растянул на четыре строки.   

```
sort [ ]   = [ ] 
sort (a:x) = sort [b; b <- x; b < a] 
             ++ [a] ++ 
             sort [b; b <- x; b >= a] 
```

Может быть для того, чтоб продемонстрировать то, что преимущества в краткости растет с ростом серьезности программ. Может какие-нибудь игрушечные примеры и короче всего в несколько раз, но посмотрите на лексер. Реальная программа в 20 раз короче! Код реальных программ, правда, не показан.   
Разработчик Lazy ML и его компилятора Томас Йонссон в своей диссертации [John87] тоже сравнивает квиксорт с "квиксортом". В Lazy ML не было ЦФ-нотации, так что он просто использовал `filter` из стандартной библиотеки для получения двухстрочника. Не включил имплементацию фильтра в пример, в отличие от Берджа и Ван Эмдена. Но у Йонссона и квиксорт на Паскале покороче, чем у Ричардса - 15 строк. Только на одну больше, чем "квиксорт" Берджа.   

### Случай на мосту через поток данных

В том же 81-ом году, когда Тернер и Дарлингтон прочитали свои лекции в Ньюкасле, состоялась вторая ФП-конференция, на которой с их идеями и языками уравнений познакомилась более широкая аудитория.   
В октябре 81-го, уже знакомые читателям по предыдущей части, группа функциональных языков и архитектуры Арвинда совместно с группой вычислительных структур Денниса организовали в Портсмуте, Нью-Гэмпшир конференцию по функциональным языкам программирования и компьютерной архитектуре (FPCA). Как и LFP, эта конференция с тех пор проходила раз в два года, только по нечетным годам, пока в 96-ом они не объединились в одну ежегодную и, скорее всего, знакомую читателю ICFP.   
Конференция была организована создателями (эмуляторов) специальных машин и они были центральной темой, но нашлось место и для мечтателей о том, у чего не будет такого мрачного будущего.   
На первой FPCA 81-го года, скорее всего, присутствовали авторы LML и разработчики его компилятора Йонссон и Августссон. Там они не только увидели доклад Тернера, но и обсуждали с ним имплементацию ФЯ. Этот разговор подтолкнул Йонссона к изобретению G-машины, но, к сожалению, не подтолкнул Тернера к работе над более-менее эффективными имплементациями ФЯ на обычном железе. Это, разумеется, оказало серьезное влияние на то, как развивалась история ФП.   
На этой конференции Тернер выступил с докладом "Семантическая элегантность аппликативных языков" [Turn81], в котором продемонстрировал написание и оптимизацию более серьезной программы, чем однострочники, которые демонстрировались до того. Серьезная программа растянулась на пару десятков строк. Сохранилась она не только в статье. Несколько вариантов этого кода поставлялись как примеры вместе с первой имплементацией KRC и её исходными кодами.   
Программа строит гомологический ряд парафинов со всеми возможными изомерами. Да, в наборе бенчмарков GHC nofib есть такая программа. Но нет, это не порт KRC-кода на Haskell. В nofib переписанное на Хаскель другое решение той же задачи, которое демонстрировало уравнения с ПМ добавленные в другой язык, о котором мы еще напишем.   
Когда программа на языке уравнений с ПМ разрастается аж до десятков строк, в ней начинают встречаться и бросаться в глаза более сложные примеры сопоставлений с образцом, использующие и вложение.   

```haskell
invert [[a,b,c],d,e,f] = [a,b,c,[d,e,f]]
invert x = x
```

Что может быть важно. Ведь, как мы выяснили в нулевой части, есть серьезные основания подозревать, что некоторые из тех немногих, кому посчастливилось увидеть примеры ПМ в 70-х, даже не поняли, что такое вложение возможно.   
На этой же конференции состоялся доклад [Darl81] про планирующуюся параллельную ФП-машину ALICE с примерами на псевдо-HOPE. Да, и тут Дарлингтон использовал примеры без `---` разделителей, вместо которых только отступы

```
MinOfList : List Integer -> Integer
   MinOfList(x::nil)  <= x
   MinOfList(x::y::L)
      <= Min(x, MinOfList(y::L))
```

Псевдокод похож на одну из версий NPL, от которых осталось меньше всего следов, но часто не имеет и обязательных сигнатур с типами. Так что слушатель докладов и читатель статей и в этот раз спасен Дарлингтоном от суровых реалий синтаксиса HOPE, близкое знакомство с которыми навряд ли способствовало бы популярности языков уравнений с ПМ.   
В первые годы 80-х уравнения с ПМ используют как язык программирования или псевдокод в статьях только имеющие какое-то отношение к разработке NPL/HOPE и SASL.   
Конференция 81-го года дает возможность посмотреть как даже Вадлер, впоследствии знаменитый своими статьями, использующими уравнения с ПМ, еще использует примеры на ISWIM с другой ассоциативностью применения функций (как обычно, в каждой статье свой ISWIM). В статье уже есть ссылки на работы Бурсталла, так что использование Вадлером ISWIM, скорее всего, последнее.   
Родственное уравнениям с ПМ направление - алгебраическая спецификация - все еще представлено уже знакомыми нам по нулевой части бывшими разработчиками AFFIRM Гуттагом [Gutt81] и Мюссером [Muss81] и все еще разработчиками SCRATCHPAD [Jenk80]. Но ближайшие исполняемые языки с паттерн-матчингом и "уравнениями" были представлены только Пролог-образными языками [Clar81] и примерами кода вроде таких

```prolog
mode merge(?,?,^)
merge(u.x,u.y,u.z) <- merge(x,y,z)
merge(u.x,v.y,u.z) <- u < v |merge(x,v.y,z)
merge(u.x,v.y,v.z) <- v < u |merge(u.x,y,z)
```

где на Прологах часто пишут обычные функции, которые проаннотированы как обычные функции. И может возникнуть вопрос: зачем вообще в таком случае писать на Прологе и смотреть на все эти неиспользуемые отличия от уравнений с ПМ?   
После вышеописанных конференций и курсов про уравнения с ПМ знают уже все, кто должен о них знать для того, чтоб в 82-ом году на судьбоносной встрече в лаборатории Резерфорда — Эплтона затянувшаяся предыстория функционального программирования наконец закончилась и началась история.   

ПРОДОЛЖЕНИЕ СЛЕДУЕТ

Литература
==========

[Alle78]: John Allen. 1978. Anatomy of LISP. McGraw-Hill, Inc., USA.   
[Alle2005]: John Allen. History, Mystery, and Ballast https://international-lisp-conference.org/2005/media/allen-slides.pdf https://international-lisp-conference.org/2005/media/allen-audio.mp3   
[Burs80]: R. M. Burstall, D. B. MacQueen, and D. T. Sannella. 1980. HOPE: An experimental applicative language. In Proceedings of the 1980 ACM conference on LISP and functional programming (LFP '80). Association for Computing Machinery, New York, NY, USA, 136–143. DOI:10.1145/800087.802799   
[Clar81]: Keith L. Clark and Steve Gregory. 1981. A relational language for parallel programming. In Proceedings of the 1981 conference on Functional programming languages and computer architecture (FPCA '81). Association for Computing Machinery, New York, NY, USA, 171–178. doi:10.1145/800223.806776   
[Darl76]: Darlington, J., & Burstall, R. M. (1976). A system which automatically improves programs. Acta Informatica, 6(1). doi:10.1007/bf00263742    
[Darl81]: John Darlington and Mike Reeve. 1981. ALICE a multi-processor reduction machine for the parallel evaluation CF applicative languages. In Proceedings of the 1981 conference on Functional programming languages and computer architecture (FPCA '81). Association for Computing Machinery, New York, NY, USA, 65–76. doi:10.1145/800223.806764   
[Darl82]: Darlington J, Henderson P, Turner DA, editors. Functional programming and its applications: an advanced course. CUP Archive; 1982 Feb 18.   
[Dijk81] Dijkstra, E. (1981). Trip report E.W. Dijkstra, Newcastle, 19-25
July 1981. Dijkstra working note EWD798. https://www.cs.utexas.edu/~EWD/transcriptions/EWD07xx/EWD798.html   
[Jenk80]: James H. Davenport and Richard D. Jenks. 1980. MODLISP. In Proceedings of the 1980 ACM conference on LISP and functional programming (LFP '80). Association for Computing Machinery, New York, NY, USA, 65–74. doi:10.1145/800087.802791   
[John87]: Johnsson, Thomas. "Compiling Lazy Functional Language." PhD Thesis, Chalmers University of Technology (1987).   
[Gutt81]: John Guttag, James Horning, and John Williams. 1981. FP with data abstraction and strong typing. In Proceedings of the 1981 conference on Functional programming languages and computer architecture (FPCA '81). Association for Computing Machinery, New York, NY, USA, 11–24. doi:10.1145/800223.806758   
[Hend80]: Henderson, Peter B.. “Functional programming - application and implementation.” Prentice Hall International Series in Computer Science (1980).   
[Hoar72]: Hoare, Charles Antony Richard. "Chapter II: Notes on data structuring." In Structured programming, pp. 83-174. 1972.   
[Hoar75]: Hoare, C.A.R. Recursive data structures. International Journal of Computer and Information Sciences 4, 105–132 (1975). doi:10.1007/BF00976239   
[Hoar22]: Krzysztof R. Apt and Tony Hoare (Eds.). 2022. Edsger Wybe Dijkstra: His Life,Work, and Legacy (1st. ed.). ACM Books, Vol. 45. Association for Computing Machinery, New York, NY, USA. doi:10.1145/3544585   
[Huda07]: Paul Hudak, John Hughes, Simon Peyton Jones, and Philip Wadler. 2007. A history of Haskell: being lazy with class. In Proceedings of the third ACM SIGPLAN conference on History of programming languages (HOPL III). Association for Computing Machinery, New York, NY, USA, 12–1–12–55. DOI:10.1145/1238844.1238856   
[McJo24]: Paul McJones, John Allen (1937-2022) and Anatomy of LISP https://mcjones.org/dustydecks/archives/2024/04/11/1249/    
[Meir83]: Meira, S. R. L. 1983 Sorting algorithms in KRC: implementation, proof and performance. Computing Laboratory rep. no. 14. University of Kent at Canterbury.   
[Meir83b]: recursion -- again from net.lang srlm@ukc.UUCP (S.R.L.Meira) (08/16/83) https://usenet.trashworldnews.com/?thread=132780   
[Muss81]: D. Kapur, D. R. Musser, and A. A. Stepanov. 1981. Operators and algebraic structures. In Proceedings of the 1981 conference on Functional programming languages and computer architecture (FPCA '81). Association for Computing Machinery, New York, NY, USA, 59–64. doi:10.1145/800223.806763   
[Rich85]: Richards, H. (1985). Applicative programming. Systems Research, 2(4), 299–306. doi:10.1002/sres.3850020409   
[SPJ82]: Simon L Peyton Jones. 1982. An investigation of the relative efficiencies of combinators and lambda expressions. In Proceedings of the 1982 ACM symposium on LISP and functional programming (LFP '82). Association for Computing Machinery, New York, NY, USA, 150–158. doi:10.1145/800068.802145   
[SPJ85]: Jones, S. L. P. (1985). Yacc in sasl — an exercise in functional programming. Software: Practice and Experience, 15(8), 807–820. doi:10.1002/spe.4380150807   
[Stee82b]: Guy L. Steele. 1982. Report on the 1980 LiSP Conference Stanford University. August 25-27, 1980. SIGPLAN Not. 17, 3 (March 1982), 22–36. doi:10.1145/947912.1361218   
[Stra67]: Strachey, Christopher S.. “Fundamental Concepts in Programming Languages.” Higher-Order and Symbolic Computation 13 (2000): 11-49.
DOI:10.1023/A:1010000313106    
[Turn79]: Turner, D. A. (1979). A new implementation technique for applicative languages. Software: Practice and Experience, 9(1), 31–49. doi:10.1002/spe.4380090105   
[Turn81]: D. A. Turner. 1981. The semantic elegance of applicative languages. In Proceedings of the 1981 conference on Functional programming languages and computer architecture (FPCA '81). Association for Computing Machinery, New York, NY, USA, 85–92. doi:10.1145/800223.806766   
[Turn82]: Turner, D.A. (1982). Recursion Equations as a Programming Language. In: Darlington, John, David Turner and Peter B. Henderson. “Functional Programming and its Applications: An Advanced Course.”   
[Turn83]: Turner, D. A. "SASL language manual (revised version)." University of Kent (1983).   
[Turn84]: Turner, D. A. (1984). Functional Programs as Executable Specifications [and Discussion]. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 312(1522), 363–388. doi:10.1098/rsta.1984.0065    
[Wadl81]: Philip Wadler. 1981. Applicative style programming, program transformation, and list operators. In Proceedings of the 1981 conference on Functional programming languages and computer architecture (FPCA '81). Association for Computing Machinery, New York, NY, USA, 25–32. doi:10.1145/800223.806759   
[Whit77]: White, Jon L. "Lisp: Program is Data: A historical perspective on MACLISP." In Proceedings of the 1977 MACSYMA Users' Conference, MIT Laboratory for Computer Science, Cambridge, Mass, pp. 181-189. 1977.   
[Whit79]: Jon L. White. NIL: A perspective. Proceedings of 1979 MACSYMA Users' Conference, Washington, D.C., June 1979. https://www.softwarepreservation.org/projects/LISP/MIT/White-NIL_A_Perspective-1979.pdf   
[Warr77]: David H D Warren, Luis M. Pereira, and Fernando Pereira. 1977. Prolog - the language and its implementation compared with Lisp. In Proceedings of the 1977 symposium on Artificial intelligence and programming languages. Association for Computing Machinery, New York, NY, USA, 109–115. doi:10.1145/800228.806939   
[Warr77b]: David H D Warren. 1977. Prolog - the language and its implementation compared with Lisp. Slides https://www.softwarepreservation.org/projects/prolog/edinburgh/doc/slides-ACM1977.pdf   